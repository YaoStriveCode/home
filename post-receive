#!/usr/bin/python

import gzip
import os
import shlex
import shutil
from subprocess import CalledProcessError, list2cmdline, PIPE, Popen
import sys

notify_to = 'jcorbin@wunjo.org'
puburl = 'http://www.wunjo.org/~jcorbin/forwork'
pubdir = '~/public_html/forwork'
pubdir = os.path.expanduser(pubdir)

def run(cmd, wait=True, ok_retcodes=(0,), **kwargs):
    if isinstance(cmd, unicode):
        cmd = cmd.encode('ascii')
    if isinstance(cmd, str):
        cmdstr = cmd
        cmd = shlex.split(cmd)
    else:
        cmdstr = list2cmdline(cmd)
    p = Popen(cmd, **kwargs)
    p.cmdstr = cmdstr
    p.cmd = cmd
    if wait:
        retcode = p.wait()
        if retcode not in ok_retcodes:
            raise CalledProcessError(retcode, p.cmdstr)
    return p

run_line = lambda cmd, **kwargs: run(
    cmd, stdout=PIPE, **kwargs).stdout.readline().strip()

def revs(*revs):
    cmd = ('git', 'rev-parse') + revs
    for rev in run(cmd, stdout=PIPE).stdout:
        yield rev.strip()

def shortrevs(*rs):
    for rev in revs(*rs):
        yield rev[:7]

def update_file(old, new, repopath, target):
    oldob, newob = revs(
        old + ':' + repopath,
        new + ':' + repopath)
    if oldob == newob: return False
    with open(target, 'w') as f:
        show = run(
            ('git', 'show', new + ':' + repopath),
            stdout=PIPE).stdout
        shutil.copyfileobj(show, f)
        print 'updated', os.path.realpath(target)
        return True

def read_checkouts(meta_ref):
    path = meta_ref + ':checkouts'
    for i, line in enumerate(run_output(('git', 'show', path))):
        line = line.strip()
        if not line: continue
        try:
            repopath, target = line.split(None, 1)
        except ValueError:
            print >>sys.stderr, \
                'bogus checkouts:{0}: {1}'.format(i+1, line)
        yield repopath, target

def index_contents():
    yield "<!doctype html>\n"
    yield "<html>"
    yield "<head><title>jcorbin home.git shell-pack stage</title></head>"
    yield "<body>"
    yield "<ul>"
    for ent in os.listdir(pubdir):
        if not ent.endswith('.sh.gz'): continue
        yield "<li><a href=\"{0}\">{0}</a></li>".format(ent)
    yield "</ul>"
    yield "</body></html>\n"

if __name__ == '__main__':
    updates = [line.strip().split(None, 2) for line in sys.stdin]

    def upgrade_self(target):
        if '--dejavu' in sys.argv: return
        if os.path.realpath(target) != os.path.realpath(sys.argv[0]): return
        r, w = os.pipe()
        os.write(w, ''.join(' '.join(t)+'\n' for t in updates))
        os.close(w)
        os.dup2(r, sys.stdin.fileno())
        os.close(r)
        print 'updated', os.path.realpath(sys.argv[0]), 're-execing'
        sys.stdout.flush()
        os.execl(os.path.realpath(sys.argv[0]), sys.argv[0], '--dejavu')

    meta_ref = 'refs/heads/meta'

    for old, new, refname in updates:
        if refname != meta_ref: continue
        for repopath, target in read_checkouts(meta_ref):
            if update_file(old, new, repopath, target):
                upgrade_self(target)

    run('git repack -Ad')
    run('git gc')

    head_ref = run_line('git symbolic-ref HEAD')
    branch = head_ref.rsplit('/', 1)[1]
    for old, new, refname in updates:
        if refname != head_ref: continue

        work, forwork = shortrevs('work/master', 'for/work/master')

        thepack = '{0}-{1}-{2}.sh.gz'.format(branch, work, forwork)
        thepack = os.path.join(pubdir, thepack)

        with gzip.GzipFile(thepack, 'w') as f:
            pack = run('git shell-pack make work', stdout=PIPE).stdout
            shutil.copyfileobj(pack, f)

        with open(os.path.join(pubdir, 'index.html'), 'w') as f:
            for s in index_contents():
                f.write(s)

        if notify_to:
            # TODO: use python module
            mail = run(('mail',
                '--to', notify_to,
                '--subject', os.path.basename(thepack) + ' available'
            ), wait=False, stdin=PIPE)
            mail.stdin.write(puburl + '/' + thepack + '\n')
            mail.stdin.close()
            mail.wait()
