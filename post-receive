#!/usr/bin/python

import gzip
import os
import shlex
import shutil
from subprocess import CalledProcessError, list2cmdline, PIPE, Popen
import sys

notify_to = 'jcorbin@wunjo.org'
puburl = 'http://www.wunjo.org/~jcorbin/drop'
pubdir = '~/public_html/drop'
pubdir = os.path.expanduser(pubdir)

def run(cmd, wait=True, ok_retcodes=(0,), **kwargs):
    if isinstance(cmd, unicode):
        cmd = cmd.encode('ascii')
    if isinstance(cmd, str):
        cmdstr = cmd
        cmd = shlex.split(cmd)
    else:
        cmdstr = list2cmdline(cmd)
    p = Popen(cmd, **kwargs)
    p.cmdstr = cmdstr
    p.cmd = cmd
    if wait:
        retcode = p.wait()
        if retcode not in ok_retcodes:
            raise CalledProcessError(retcode, p.cmdstr)
    return p

run_line = lambda cmd, **kwargs: run(
    cmd, stdout=PIPE, **kwargs).stdout.readline().strip()

def revs(*revs):
    if not len(revs): return None
    cmd = ('git', 'rev-parse') + revs
    p = run(cmd, stdout=PIPE)
    if len(revs) == 1:
        return p.stdout.readline().strip()
    else:
        return (rev.strip() for rev in p.stdout)

def shortrevs(*rs):
    for rev in revs(*rs):
        yield rev[:7]

def path_sha(rev, path):
    if rev == '0' * 40: return None
    try:
        return revs(rev + ':' + repopath)
    except CalledProcessError:
        return None

def update_file(old, new, repopath, target):
    oldob = path_sha(old, repopath)
    newob = path_sha(new, repopath)
    if oldob == newob: return False
    target = os.path.realpath(target)
    if newob is None:
        os.unlink(target)
        return True
    with open(target, 'w') as f:
        show = run(
            ('git', 'show', new + ':' + repopath),
            stdout=PIPE).stdout
        shutil.copyfileobj(show, f)
        print 'updated', target
        return True

def read_checkouts(meta_ref):
    path = meta_ref + ':checkouts'
    for i, line in enumerate(run_output(('git', 'show', path))):
        line = line.strip()
        if not line: continue
        try:
            repopath, target = line.split(None, 1)
        except ValueError:
            print >>sys.stderr, \
                'bogus checkouts:{0}: {1}'.format(i+1, line)
        yield repopath, target

def index_contents():
    yield "<!doctype html>\n"
    yield "<html>"
    yield "<head><title>jcorbin home.git shell-pack stage</title></head>"
    yield "<body>"
    yield "<ul>"
    for ent in os.listdir(pubdir):
        if not ent.endswith('.sh.gz'): continue
        yield "<li><a href=\"{0}\">{0}</a></li>".format(ent)
    yield "</ul>"
    yield "</body></html>\n"

if __name__ == '__main__':
    updates = [line.strip().split(None, 2) for line in sys.stdin]

    self_files = (
        os.path.realpath(sys.argv[0]),
    )

    def upgrade_self(target):
        if '--dejavu' in sys.argv: return
        if os.path.realpath(target) not in self_files: return
        r, w = os.pipe()
        os.write(w, ''.join(' '.join(t)+'\n' for t in updates))
        os.close(w)
        os.dup2(r, sys.stdin.fileno())
        os.close(r)
        print 'updated', os.path.realpath(sys.argv[0]), 're-execing'
        sys.stdout.flush()
        os.execl(os.path.realpath(sys.argv[0]), sys.argv[0], '--dejavu')

    meta_ref = 'refs/heads/meta'

    for old, new, refname in updates:
        if refname != meta_ref: continue
        for repopath, target in read_checkouts(meta_ref):
            if update_file(old, new, repopath, target):
                upgrade_self(target)

    run('git repack -Ad')
    run('git gc')

    head_ref = run_line('git symbolic-ref HEAD')
    branch = head_ref.rsplit('/', 1)[1]
    for old, new, refname in updates:
        if refname != head_ref: continue

        try:
            run('git show-ref --verify --quiet for/drop/master')
        except CalledProcessError:
            pass
        else:
            run(os.path.join(os.getcwd(), 'ack'))

        pack = run('git shell-pack make drop', stdout=PIPE).stdout
        drop, fordrop = shortrevs('drop/master', 'for/drop/master')

        thepack = '{0}-{1}-{2}.sh.gz'.format(branch, drop, fordrop)

        with gzip.GzipFile(os.path.join(pubdir, thepack), 'w') as f:
            shutil.copyfileobj(pack, f)

        for ent in os.listdir(pubdir):
            if ent == thepack: continue
            if not ent.startswith(branch + '-'): continue
            os.unlink(os.path.join(pubdir, ent))

        with open(os.path.join(pubdir, 'index.html'), 'w') as f:
            for s in index_contents():
                f.write(s)

        if notify_to:
            # TODO: use python module
            with open('description') as f:
                desc = f.readline().strip()
            subject = '{0}: {1} available'.format(desc, thepack)
            mail = run(('mail',
                '--to', notify_to,
                '--subject', subject
            ), wait=False, stdin=PIPE)
            mail.stdin.write(puburl + '/' + thepack + '\n')
            mail.stdin.close()
            mail.wait()
