#!/usr/bin/perl

# Unfuck newlines in a lot of files, oh the things we do to work with people on
# braindead systems.

use strict;
use warnings FATAL => 'all';

use IO::Handle;
STDOUT->autoflush(1);

use File::Basename;
use File::Find;

use constant MODE_UNIX => 0;
use constant MODE_DOS  => 1;

our $Mode = MODE_UNIX;
our @Paths;

parse_args();

our $Nl;
if ( $Mode == MODE_UNIX ) {
	$Nl = "\n";
} else {
	$Nl = "\r\n";
}

our $File;
for $File ( @Paths ) {
	my ( $name, $dir ) = fileparse( $File );
	my $temp = "$dir/.$name.unfucked";

	my ( $in, $out );
	open $in, '<', $File ||
		die "Failed to read $File: $!\n";
	open $out, '>', $temp ||
		die "Failed to write $temp: $!\n";

	print "< $File\n> $temp\n";

	while ( $_ = <$in> ) {
		s/\r?\n$//g;
		print $out "$_$Nl";
	}

	rename( $temp, $File ) ||
		die "Failed to rename $temp -> $File: $!\n";

	close $in;
	close $out;
}

exit 0;

sub parse_args {
	my @pats;
	my $do_file = sub {
		my $f = shift;
		if ( $#pats > -1 ) {
			for my $pat ( @pats ) {
				if ( $f =~ $pat ) {
					push @Paths, $f;
					return;
				}
			}
		} else {
			push @Paths, $f;
		}
	};

	while ( $_ = shift @ARGV ) {
		if ( /^\-m(?:ode)?/i ) {
			my $m = shift @ARGV || syntax( "Missing mode argument" );
			$m = lc( substr( $m, 0, 1 ) );
			if ( $m eq 'u' ) {
				$Mode = MODE_UNIX;
			} elsif ( $m eq 'd' ) {
				$Mode = MODE_DOS;
			} else {
				syntax( "Invalid mode argument" );
			}
		} elsif ( /^-n(?:ame)?/i ) {
			my $g = shift @ARGV || syntax( "Missing name pattern" );
			push @pats, qr/$g/i;
		} else {
			($_) = $_ =~ qr|^([-+@\w./]+)$| or syntax( "Invalid path: $_" );
			if ( -f $_ ) {
				&$do_file( $_ );
			} elsif ( -d $_ ) {
				find( {
					wanted => sub {
						&$do_file( $File::Find::name );
					},
					no_chdir => 1,
					follow => 1
				}, $_ );
			} else {
				syntax( "Not a file or directory: $_" );
			}
		}
	}

	@Paths || syntax( "No paths given" );
}

sub syntax {
	my $mess = shift;
	my ($progname) = $0 =~ /\/(.+)$/;
	print STDERR
		( defined $mess ? "$mess\n\n" : '' ) .
		"Syntax: $progname [-mode unix|dos] [-name <pattern>] <path> [ <path> [ ... ] ]\n" .
		"  -mode specifies output mode, default is unix.\n\n" .
		"  -name specifies optional glob to limit files.\n" .
		"        can be given multiple times to add to list of inclusive patterns.\n\n" .
		"  paths are files or directories.\n";
	exit 1 ;
}
