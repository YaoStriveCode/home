#!/bin/bash

if [ $# -eq 0 ]; then
    set -- -h
fi
OPTIONS_SPEC="\
git shell-pack make <remote> [<ref> [<ref> [...]]]

Builds a self-extracting pack file for the remote.

If no refs are given, then all matching refs for the remote are exported.

The shell script is output on stdout.
--
h,help        show the help
"

. "$(git --exec-path)/git-sh-setup"

while [ $# -gt 0 ]; do
    opt="$1"
    shift
    case "$opt" in
        --) break ;;
        *) die "Unexpected option: $opt" ;;
    esac
done

set -e

make_pack()
{
    cat <<EOSCRIPT
#!/bin/sh
set -x

if [ \$# -lt 1 ]; then
    echo "Usage \$0 <remote>"
    echo
    echo "Imports the encapsulated packed objects and updates the shipped refs"
    echo "under the given remote."
    exit 1
fi

remote=\$1

base64 -d <<EOPACK | git unpack-objects
EOSCRIPT

    for ref in $refs; do
        rev=$(git rev-parse $ref)
        if from=$(git rev-parse $remote/$ref 2>/dev/null); then
            git rev-list $from..$rev
        else
            git rev-list $rev
        fi
        git update-ref -m 'Prepared Pack' refs/remotes/for/$remote/$ref $rev
    done | sort -u \
    | git pack-objects --revs --stdout --all-progress | base64

    echo EOPACK
    echo

    for ref in $refs; do
        rev=$(git rev-parse $ref)
        echo "git update-ref -m 'Pack import' refs/remotes/\$remote/$ref $rev"
    done
}

[ $# -eq 0 ] && die 'Missing command argument'
command=$1
shift

[ $# -eq 0 ] && die 'Missing remote argument'
remote=$1
shift

case "$command" in
make)
    if [ $# -eq 0 ]; then
        refs=$(ls .git/refs/remotes/$remote)
    else
        refs=$@
    fi

    make_pack
    ;;
*) die "Invalid command: $command" ;;
esac
