#!/bin/bash

if [ $# -eq 0 ]; then
    set -- -h
fi
OPTIONS_SPEC="\
git shell-pack seed <remote> [<ref> [<ref> [...]]]
git shell-pack make <remote> [<ref> [<ref> [...]]]
git shell-pack ack  <remote>

'seed' builds a self-extracting seed file for the remote.  A seed file is just
       like a pack file, except it includes logic to run git-init and otherwise
       sets things up.  If no refs are given, all refs/heads/* are used.

'make' builds a self-extracting pack file for the remote.  If no refs are
       given, then all matching refs for the remote are exported.  The shell
       script is output on stdout.  The refs packed are recorded in
       refs/remotes/for/<remote>/* for:

'ack' acknowledges reception of a pack by updating refs/remotes/* with the
      revisions recorded by 'make' in refs/remotes/for/<remote>/*.
--
h,help        show the help
"

. "$(git --exec-path)/git-sh-setup"

while [ $# -gt 0 ]; do
    opt="$1"
    shift
    case "$opt" in
        --) break ;;
        *) die "Unexpected option: $opt" ;;
    esac
done

set -e

make_pack()
{
    [ -z "$header" ] && header="\
if [ \$# -ge 1 ]; then
    remote=\$1
elif ! remote=\$(git config shell-pack.remote); then
    echo \"Must pass a remote to \$0, or set shell-pack.remote\" >&2
    exit 1
fi"
    footer=""
    commits=""

    for ref in $refs; do
        refname=${ref##*/}
        src=$(git rev-parse $ref) || die "Invalid rev $ref"
        if from=$(git rev-parse $remote/$refname 2>/dev/null); then
            commits+=" ^$from"
        fi
        commits+=" $src"
        git update-ref -m 'Prepared Pack' refs/remotes/for/$remote/$refname $src

        footer+="git update-ref -m 'Pack import' refs/remotes/\$remote/$refname $src\n"
        footer+="echo Imported $src to \$remote/$refname\n"
    done

    packsha=$(git rev-list --objects $commits | cut -d' '  -f1 \
        | git pack-objects --all-progress .git/objects/pack/pack)
    pack_data=$(tar -czC .git/objects pack/pack-$packsha.{idx,pack} | base64)
    rm -f .git/objects/pack/pack-$packsha.{idx,pack}

    cat <<EOSCRIPT
#!/bin/sh
set -e

$header

base64 -d <<EOPACK | tar -xzC .git/objects
$pack_data
EOPACK

$(echo -ne $footer)
$trailer
EOSCRIPT
}

make_seed()
{
    head_branch=$(git symbolic-ref HEAD)
    head_branch=${head_branch##*/}
    their_remote=origin
    header="\
remote=$their_remote

if [ \$# -gt 0 ]; then
    [ -d \$1 ] || mkdir -p \$1
    cd \$1
fi

git init
git remote add \$remote null://shell-pack
git config shell-pack.remote \$remote
[ \$(git symbolic-ref HEAD) != refs/heads/$head_branch ] && git symbolic-ref HEAD refs/heads/$head_branch"

    trailer="
git update-ref -m 'Seed shell-pack import' refs/heads/$head_branch \$remote/$head_branch
git checkout"
    make_pack
}

[ $# -eq 0 ] && die 'Missing command argument'
command=$1
shift

[ $# -eq 0 ] && die 'Missing remote argument'
remote=$1
shift

case "$command" in
seed)
    if [ $# -eq 0 ]; then
        refs=$(git for-each-ref --format='%(refname)' 'refs/heads/*')
    else
        refs=$@
    fi

    make_seed
    ;;
make)
    if [ $# -eq 0 ]; then
        refs=$(git for-each-ref --format='%(refname)' "refs/remotes/$remote/*" \
            | sed -e "s~^refs/remotes/$remote~refs/heads~")
    else
        refs=$@
    fi

    make_pack
    ;;
ack)
    git for-each-ref --format='%(objectname) %(refname)' "refs/remotes/for/$remote/*" \
    | while read rev forref; do
        ref=${forref##*/}
        git update-ref -m 'Acked pack' refs/remotes/$remote/$ref $rev
        git update-ref -d $forref $rev
        echo "Acked $remote/$ref $rev"
    done
    ;;
*) die "Invalid command: $command" ;;
esac
