#!/bin/bash

if [ $# -eq 0 ]; then
    set -- -h
fi
OPTIONS_SPEC="\
git shell-pack make <remote> [<ref> [<ref> [...]]]
git shell-pack ack  <remote>

'make' builds a self-extracting pack file for the remote.  If no refs are
       given, then all matching refs for the remote are exported.  The shell
       script is output on stdout.  The refs packed are recorded in
       refs/remotes/for/<remote>/* for:

'ack' acknowledges reception of a pack by updating refs/remotes/* with the
      revisions recorded by 'make' in refs/remotes/for/<remote>/*.
--
h,help        show the help
"

. "$(git --exec-path)/git-sh-setup"

while [ $# -gt 0 ]; do
    opt="$1"
    shift
    case "$opt" in
        --) break ;;
        *) die "Unexpected option: $opt" ;;
    esac
done

set -e

pack_template="cat <<EOSCRIPT
#!/bin/sh
set -e

if [ \\\$# -ge 1 ]; then
    remote=\\\$1
elif ! remote=\\\$(git config shell-pack.remote); then
    echo \"Must pass a remote to \\\$0, or set shell-pack.remote\" >&2
    exit 1
fi

base64 -d <<EOPACK | tar -xzC .git/objects
\$pack_data
EOPACK

\$(echo -ne \$footer)
EOSCRIPT"

make_pack()
{
    footer=""
    commits=""

    for ref in $refs; do
        refname=${ref##*/}
        src=$(git rev-parse $ref) || die "Invalid rev $ref"
        if from=$(git rev-parse $remote/$refname 2>/dev/null); then
            commits+=" ^$from"
        fi
        commits+=" $src"
        git update-ref -m 'Prepared Pack' refs/remotes/for/$remote/$refname $src

        footer+="git update-ref -m 'Pack import' refs/remotes/\$remote/$refname $src\n"
        footer+="echo Imported $src to \$remote/$refname\n"
    done

    packsha=$(git rev-list --objects $commits | cut -d' '  -f1 \
        | git pack-objects --all-progress .git/objects/pack/pack)
    pack_data=$(tar -czC .git/objects pack/pack-$packsha.{idx,pack} | base64)
    rm -f .git/objects/pack/pack-$packsha.{idx,pack}

    eval "$pack_template"
}

[ $# -eq 0 ] && die 'Missing command argument'
command=$1
shift

[ $# -eq 0 ] && die 'Missing remote argument'
remote=$1
shift

case "$command" in
make)
    if [ $# -eq 0 ]; then
        refs=$(ls .git/refs/remotes/$remote)
    else
        refs=$@
    fi

    make_pack
    ;;
ack)
    git for-each-ref --format='%(objectname) %(refname)' "refs/remotes/for/$remote/*" \
    | while read rev forref; do
        ref=${forref##*/}
        git update-ref -m 'Acked pack' refs/remotes/$remote/$ref $rev
        git update-ref -d $forref $rev
        echo "Acked $remote/$ref $rev"
    done
    ;;
*) die "Invalid command: $command" ;;
esac
